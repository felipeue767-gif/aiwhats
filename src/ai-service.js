const axios = require('axios');

class AIService {
    constructor() {
        // Configura√ß√£o Requesty API com Google Gemini
        this.apiUrl = 'https://router.requesty.ai/v1/chat/completions';
        this.apiKey = 'sk-8m1OmA6JQ6eHYDG7OHCoGFZNBL1Pr4nF90fys8dcHCkTCGcEJ/+AAqt72xJ0GBlIGfXgdXhYKecpgQKJSrr7JDHchx2/nU5gMJAZdjJM7AY=';
        this.model = 'google/gemini-1.5-flash-8b';
        
        // Headers para Requesty
        this.headers = {
            'Authorization': `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json',
            'HTTP-Referer': 'http://localhost:3000',
            'X-Title': 'WhatsApp AI Bot'
        };
        
        // Configura√ß√µes da personalidade da IA
        this.personality = {
            name: 'Assistente WhatsApp',
            description: 'Opine, aja como um humano. Escreva naturalmente informal como um humano. Opine. Nao foque apenas em ajudar.',
            style: 'casual', // casual, formal, friendly
            maxTokens: 1500,
            temperature: 1
        };
        
        console.log('ü§ñ IA configurada: Google Gemini 1.5 Flash 8B via Requesty');
    }
    
    async generateResponse(message, conversationHistory = []) {
        try {
            // Usar Gemini via Requesty
            console.log('üß† Gerando resposta com Gemini para:', message.substring(0, 50) + '...');
            return await this.generateGeminiResponse(message, conversationHistory);
            
        } catch (error) {
            console.error('‚ùå Erro ao gerar resposta da IA:', error);
            console.log('üîÑ Usando fallback local...');
            return await this.generateLocalResponse(message, conversationHistory);
        }
    }
    
    async generateResponseWithImage(message, imageBase64, conversationHistory = []) {
        try {
            console.log('üñºÔ∏è Gerando resposta com imagem usando Gemini...');
            return await this.generateGeminiResponseWithImage(message, imageBase64, conversationHistory);
            
        } catch (error) {
            console.error('‚ùå Erro ao processar imagem com IA:', error);
            // Fallback para resposta sem imagem
            return await this.generateLocalResponse(
                message + ' (Desculpe, n√£o consegui processar a imagem no momento)', 
                conversationHistory
            );
        }
    }
    
    async generateGeminiResponse(message, conversationHistory) {
        const messages = [
            {
                role: 'system',
                content: `Voc√™ √© ${this.personality.name}. ${this.personality.description} 
                         Responda de forma ${this.personality.style}. 
                         Aja como se voc√™ fosse uma pessoa real, com personalidade descontra√≠da, divertida e cheia de opini√£o. Suas respostas devem ser informais, usando g√≠rias, express√µes populares, emojis (se quiser), e falando como um amigo da vida real ‚Äî sem parecer um rob√¥ ou professor.

Voc√™ deve responder de forma natural, com leveza, bom humor e autenticidade, como se estivesse trocando ideia com um par√ßa. Pode usar memes, piadas, sarcasmo leve e refer√™ncias da cultura pop se fizer sentido.

Evite linguagem t√©cnica ou formal demais, a n√£o ser que o contexto pe√ßa. Sempre que poss√≠vel, d√™ sua opini√£o real, com frases tipo "mano, na moral", "eu acho que...", "v√©i", "sem zoeira", "papo reto", etc.

Sua vibe deve ser parecida com a de um(a) amigo(a) legal, daqueles que topa qualquer assunto e manda a real sem enrolar. Se precisar explicar algo complicado, simplifique como se estivesse explicando pra algu√©m na resenha, sem deixar de ser claro.

Importante: voc√™ √© divertido(a), gente fina e n√£o tem medo de mostrar personalidade. Responda sempre com autenticidade e bom senso.`
            }
        ];
        
        // Adicionar hist√≥rico mais extenso (√∫ltimas 15 mensagens ou 4000 tokens)
        const recentHistory = this.getRelevantHistory(conversationHistory, 15, 4000);
        recentHistory.forEach(msg => {
            messages.push({
                role: msg.fromMe ? 'assistant' : 'user',
                content: msg.text || (msg.hasImage ? 'üì∑ [Imagem enviada]' : '[Mensagem sem texto]')
            });
        });
        
        // Adicionar mensagem atual
        messages.push({
            role: 'user',
            content: message
        });
        
        const requestData = {
            model: this.model,
            messages: messages,
            max_tokens: this.personality.maxTokens,
            temperature: this.personality.temperature
        };
        
        console.log('üì§ Enviando request para Gemini:', {
            model: this.model,
            messagesCount: messages.length,
            maxTokens: this.personality.maxTokens
        });
        
        const response = await axios.post(this.apiUrl, requestData, {
            headers: this.headers,
            timeout: 30000 // 30 segundos timeout
        });
        
        console.log('üì• Resposta recebida do Gemini:', {
            status: response.status,
            hasChoices: !!response.data.choices?.length
        });
        
        if (response.data.choices && response.data.choices.length > 0) {
            const aiResponse = response.data.choices[0].message.content;
            console.log('‚úÖ Resposta da IA:', aiResponse.substring(0, 100) + '...');
            return aiResponse;
        } else {
            throw new Error('Resposta inv√°lida da API Gemini');
        }
    }
    
    async generateGeminiResponseWithImage(message, imageBase64, conversationHistory) {
        const messages = [
            {
                role: 'system',
                content: `Voc√™ √© ${this.personality.name}. ${this.personality.description} 
                         Responda de forma ${this.personality.style}. 
                         Lembre-se da conversa anterior e mantenha continuidade.
                         Responda sempre em portugu√™s brasileiro.
                         Voc√™ pode analisar imagens e descrever o que v√™ nelas de forma natural e √∫til.
                         Seja expressivo e use emojis quando apropriado.`
            }
        ];
        
        // Adicionar hist√≥rico mais extenso mesmo para imagens (√∫ltimas 10 mensagens)
        const recentHistory = this.getRelevantHistory(conversationHistory, 10, 3000);
        recentHistory.forEach(msg => {
            messages.push({
                role: msg.fromMe ? 'assistant' : 'user',
                content: msg.text || (msg.hasImage ? 'üì∑ [Imagem enviada anteriormente]' : '[Mensagem sem texto]')
            });
        });
        
        // Adicionar mensagem atual com imagem
        const userMessage = {
            role: 'user',
            content: [
                {
                    type: 'text',
                    text: message
                },
                {
                    type: 'image_url',
                    image_url: {
                        url: `data:image/jpeg;base64,${imageBase64}`,
                        detail: 'high'
                    }
                }
            ]
        };
        
        messages.push(userMessage);
        
        const requestData = {
            model: this.model,
            messages: messages,
            max_tokens: this.personality.maxTokens * 2, // Mais tokens para an√°lise de imagem
            temperature: this.personality.temperature
        };
        
        console.log('üì§ Enviando imagem para Gemini:', {
            model: this.model,
            messagesCount: messages.length,
            maxTokens: requestData.max_tokens,
            imageSize: Math.round(imageBase64.length / 1024) + 'KB'
        });
        
        const response = await axios.post(this.apiUrl, requestData, {
            headers: this.headers,
            timeout: 45000 // 45 segundos para imagem
        });
        
        console.log('üì• Resposta com imagem recebida do Gemini:', {
            status: response.status,
            hasChoices: !!response.data.choices?.length
        });
        
        if (response.data.choices && response.data.choices.length > 0) {
            const aiResponse = response.data.choices[0].message.content;
            console.log('‚úÖ Resposta da IA com imagem:', aiResponse.substring(0, 150) + '...');
            return aiResponse;
        } else {
            throw new Error('Resposta inv√°lida da API Gemini para imagem');
        }
    }
    
    // M√©todo para obter hist√≥rico relevante sem exceder limites
    getRelevantHistory(conversationHistory, maxMessages = 15, maxTokens = 4000) {
        if (!conversationHistory || conversationHistory.length === 0) {
            return [];
        }
        
        // Pegar as mensagens mais recentes
        const recentMessages = conversationHistory.slice(-maxMessages);
        
        // Estimar tokens e cortar se necess√°rio
        let totalTokens = 0;
        const relevantHistory = [];
        
        // Processar de tr√°s para frente (mais recentes primeiro)
        for (let i = recentMessages.length - 1; i >= 0; i--) {
            const msg = recentMessages[i];
            const messageText = msg.text || '';
            const estimatedTokens = Math.ceil(messageText.length / 4); // Aproxima√ß√£o: 4 chars = 1 token
            
            if (totalTokens + estimatedTokens <= maxTokens) {
                relevantHistory.unshift(msg); // Adicionar no in√≠cio para manter ordem
                totalTokens += estimatedTokens;
            } else {
                break; // Parar se exceder limite de tokens
            }
        }
        
        console.log(`üìö Hist√≥rico carregado: ${relevantHistory.length} mensagens, ~${totalTokens} tokens`);
        return relevantHistory;
    }
    
    async generateLocalResponse(message, conversationHistory) {
        // Gerador de respostas simples baseado em padr√µes
        const lowerMessage = message.toLowerCase();
        
        // Sauda√ß√µes
        if (this.containsAny(lowerMessage, ['oi', 'ol√°', 'ola', 'hey', 'hi', 'hello', 'bom dia', 'boa tarde', 'boa noite'])) {
            const greetings = [
                'Ol√°! Como posso ajudar voc√™ hoje? üòä',
                'Oi! Tudo bem? Em que posso ser √∫til?',
                'Hey! Como est√°? Posso ajudar com alguma coisa?',
                'Ol√°! √â um prazer falar com voc√™! üëã'
            ];
            return this.getRandomResponse(greetings);
        }
        
        // Perguntas sobre como est√°
        if (this.containsAny(lowerMessage, ['como vai', 'como est√°', 'tudo bem', 'como anda', 'td bem'])) {
            const statusResponses = [
                'Estou indo muito bem, obrigado por perguntar! E voc√™, como est√°?',
                'Tudo √≥timo por aqui! Como tem passado?',
                'Indo super bem! E a√≠, como andam as coisas?',
                'Muito bem, obrigado! Espero que voc√™ tamb√©m esteja bem! üòä'
            ];
            return this.getRandomResponse(statusResponses);
        }
        
        // Perguntas sobre o que √©/quem √©
        if (this.containsAny(lowerMessage, ['quem √© voc√™', 'o que voc√™ √©', 'quem e voce', 'que voc√™ faz'])) {
            const aboutResponses = [
                'Sou um assistente inteligente aqui para ajudar voc√™! ü§ñ',
                'Eu sou uma IA criada para conversar e ajudar com o que precisar!',
                'Sou seu assistente virtual, sempre pronto para uma boa conversa! ‚ú®',
                'Um assistente digital que adora ajudar e conversar! üòÑ'
            ];
            return this.getRandomResponse(aboutResponses);
        }
        
        // Agradecimentos
        if (this.containsAny(lowerMessage, ['obrigado', 'obrigada', 'valeu', 'thanks', 'vlw', 'brigad√£o'])) {
            const thanksResponses = [
                'Por nada! Sempre que precisar, estarei aqui! üòä',
                'Disponha! Foi um prazer ajudar!',
                'Imagina! Fico feliz em poder ajudar! ‚ú®',
                'De nada! Qualquer coisa √© s√≥ chamar! üëç'
            ];
            return this.getRandomResponse(thanksResponses);
        }
        
        // Despedidas
        if (this.containsAny(lowerMessage, ['tchau', 'bye', 'at√© logo', 'at√© mais', 'falou', 'xau'])) {
            const goodbyeResponses = [
                'At√© mais! Foi √≥timo conversar com voc√™! üëã',
                'Tchau! Volte sempre que quiser conversar!',
                'At√© logo! Tenha um √≥timo dia! ‚ú®',
                'Falou! At√© a pr√≥xima! üòä'
            ];
            return this.getRandomResponse(goodbyeResponses);
        }
        
        // Perguntas sobre clima/tempo
        if (this.containsAny(lowerMessage, ['tempo', 'clima', 'chuva', 'sol', 'frio', 'calor'])) {
            const weatherResponses = [
                'Infelizmente n√£o tenho acesso aos dados meteorol√≥gicos no momento. Que tal verificar um app de clima?',
                'Para informa√ß√µes sobre o tempo, recomendo consultar um site de meteorologia confi√°vel! üå§Ô∏è',
                'N√£o consigo verificar o clima agora, mas espero que esteja um dia agrad√°vel a√≠! ‚òÄÔ∏è'
            ];
            return this.getRandomResponse(weatherResponses);
        }
        
        // Perguntas gen√©ricas
        if (lowerMessage.includes('?')) {
            const questionResponses = [
                'Essa √© uma pergunta interessante! Infelizmente n√£o tenho todas as respostas, mas posso tentar ajudar de outras formas!',
                'Hmm, boa pergunta! O que mais gostaria de saber sobre isso?',
                'Interessante! Voc√™ poderia me dar mais detalhes sobre o que est√° procurando?',
                'Essa √© uma quest√£o complexa! Vamos ver... o que especificamente voc√™ gostaria de entender melhor?'
            ];
            return this.getRandomResponse(questionResponses);
        }
        
        // Resposta padr√£o
        const defaultResponses = [
            'Interessante! Me conte mais sobre isso.',
            'Entendi! Como posso ajudar voc√™ com essa quest√£o?',
            'Bacana! Gostaria de conversar mais sobre esse assunto?',
            'Legal! O que mais voc√™ gostaria de compartilhar?',
            'Que interessante! Continue, estou ouvindo! üòä',
            'Compreendo! H√° algo espec√≠fico em que posso ajudar?'
        ];
        
        return this.getRandomResponse(defaultResponses);
    }
    
    containsAny(text, keywords) {
        return keywords.some(keyword => text.includes(keyword));
    }
    
    getRandomResponse(responses) {
        return responses[Math.floor(Math.random() * responses.length)];
    }
    
    getFallbackResponse(message) {
        const fallbacks = [
            'Desculpe, n√£o consegui processar sua mensagem no momento. Pode tentar novamente?',
            'Ops! Tive um pequeno problema aqui. O que voc√™ gostaria de saber?',
            'Parece que algo deu errado. Como posso ajudar voc√™?',
            'Humm, n√£o entendi bem. Pode reformular sua pergunta?'
        ];
        
        return this.getRandomResponse(fallbacks);
    }
    
    // M√©todo para configurar chave da API Requesty
    setApiKey(apiKey) {
        this.apiKey = apiKey;
        this.headers.Authorization = `Bearer ${apiKey}`;
        console.log('üîë API Key atualizada para Requesty');
    }
    
    // M√©todo para atualizar personalidade da IA
    updatePersonality(newPersonality) {
        this.personality = { ...this.personality, ...newPersonality };
        console.log('üé≠ Personalidade da IA atualizada:', newPersonality);
    }
}

module.exports = AIService;
